<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[手机+pc代理软件使用教程]]></title>
    <url>%2F2019%2Fssr%2Fd0edc1ed.html</url>
    <content type="text"><![CDATA[手机和PC端代理软件使用教程，内含软件下载链接 先祝大家新春快乐！！嘻嘻🙃🙃 不废话了，开始吧。 手机端使用方法下载客户端网上有很多的Android端的代理客户端，但是为了防止后台上传服务器地址和端口偷用流量，我们还是使用GitHub上开源的手机端app—shadowsocks-android，然后将下载好的apk文件安装到手机。 基本配置打开手机端app，然后点击右上角奥的”+”，选择手动配置，然后填写配置选项，如下图： 其中服务器填写服务器IP地址就可以，远程端口根据服务器端的设置填写，密码和加密方式也一样，带规则根据自己的需要进行选择，全局代理就是所有的流量都会走代理，所有如果访问过国内的网站会很慢。我们一般选择PAC模式，也就是绕过局域网和中国大陆。这样如果访问防火墙以外的网站的就会自动走代理，但是有时候可能PAC规则更新不够及时，会导致一些墙外的网站无法在PAC模式下访问，这是就需要更改到全局模式。 Windows系统的使用方法其实PC端使用的方法和上面的手机端大同小异，这里还是简单介绍一下配置方法。 下载客户端同样的网上的开源程序也有很多，所以我们同样选择GitHub上的开源软件，我使用的软件我忘了GitHub地址，所以只好放在网盘里供大家使用了。点击下载，提取码：9y0b 基本配置下载好之后进行配置，如下图： 配置同上。 然后右键右下方的小飞机，设置如下图: 其中系统代理模式可以选择不同的代理模式，根据自己需要进行选择。 Linux系统的使用方法待更新]]></content>
      <categories>
        <category>ssr</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raspberry初始化配置]]></title>
    <url>%2F2019%2Fraspberry-init%2F225c7983.html</url>
    <content type="text"><![CDATA[对于刚拿到手的树莓派应该如何配置呢？这里记录了一些基本的配置方法。 烧录系统下图是我买的树莓派套餐： 下载镜像首先去官网下载镜像 然后使用Win32DiskImager将下载好的镜像烧录到16G的TF卡中，软件可以点击这里下载。 远程连接如果没有显示器，则可以使用如下方法来配置ssh进行远程登陆。 镜像烧录好之后打开文件夹，然后在文件夹中创建一个名为ssh的文件。 注意：文件名是ssh，不是ssh.txt 配置好之后就可以进行远程登陆了。 连接WiFi同样的，如果没有显示器，需要向上一步一样创建一个名为wpa_supplicant.conf的文件。文件内容如下： 123456789country=GBctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123; ssid=&quot;WiFi名&quot; psk=&quot;WiFi密码&quot; priority=数字，越大代表优先级越高&#125; 其中network可以配置多个，并分配不同的优先级 通过以上这些步骤，我们已经可以使用ssh远程连接我们的树莓派了 其他教程是使用如下命令来连接树莓派的： 1ssh pi@raspberrypi.local 但是我没有连接成功，我使用的命令是ssh pi@IP地址，那么问题来了，我们怎么知道树莓派的IP地址呢？这里介绍两种方法来查看树莓派的IP。 方法一：查看路由器，在win命令行中输入ipconfig 找到默认网关，然后在浏览器中输入默认网关地址查看树莓派的IP地址 方法二：使用扫描工具扫描IP段，我使用的工具是Advanced IP Scanner，扫描结果如下图所示： 然后使用ssh连接即可 自动连接WiFi有一种尴尬的情况就是突然网断了，接着也就和树莓派失去了联系。我们应该如何防止这种突发状况呢？我们可以使用一个脚本进行定时检测，然后自动重连WiFi。下面为配置方法： 1、Python 代码 autowifi.py，放在 /home/pi 目录下: 12345678#!/usr/bin/pythonimport os, time while True: ' not in os.popen('sudo wpa_cli status').read(): print '\n****** wifi is down, restart... ******\n' os.system('sudo ifup wlan0') time.sleep() # minutes 2、Shell脚本autowifi.sh，也放在 /home/pi 目录下: 12#!/bin/shpython /home/pi/autowifi.py &amp; 3、开机自动启动以上脚本：在终端窗口执行以下命令即可 1234sudo cp -f /home/pi/autowifi.sh /etc/init.d/sudo chmod +x /etc/init.d/autowifi.shsudo chown root:root /etc/init.d/autowifi.shsudo update-rc.d autowifi.sh defaults]]></content>
      <categories>
        <category>玩</category>
      </categories>
      <tags>
        <tag>raspberry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx反向代理]]></title>
    <url>%2F2018%2Fnginx-proxy%2Fdfa9b87c.html</url>
    <content type="text"><![CDATA[终于配置好了反向代理，简单记录一下。一、 概述 什么是反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。 二、 反向代理服务器的工作原理 防止web服务器被攻击 如果您的内容服务器具有必须保持安全的敏感信息，如信用卡号数据库，可在防火墙外部设置一个代理服务器作为内容服务器的替身。当外部客户机尝试访问内容服务器时，会将其送到代理服务器。实际内容位于内容服务器上，在防火墙内部受到安全保护。代理服务器位于防火墙外部，在客户机看来就像是内容服务器。 当客户机向站点提出请求时，请求将转到代理服务器。然后，代理服务器通过防火墙中的特定通路，将客户机的请求发送到内容服务器。内容服务器再通过该通道将结果回传给代理服务器。代理服务器将检索到的信息发送给客户机，好像代理服务器就是实际的内容服务器。如果内容服务器返回错误消息，代理服务器会先行截取该消息并更改标头中列出的任何 URL，然后再将消息发送给客户机。如此可防止外部客户机获取内部内容服务器的重定向 URL。这样，代理服务器就在安全数据库和可能的恶意攻击之间提供了又一道屏障。与有权访问整个数据库的情况相对比，就算是侥幸攻击成功，作恶者充其量也仅限于访问单个事务中所涉及的信息。未经授权的用户无法访问到真正的内容服务器，因为防火墙通路只允许代理服务器有权进行访问。 三、博客反向代理免备案方案 + SLL证书 假设我有两个服务器A和B，服务器A在国外，B在国内，我用A作为代理服务器来转发请求给B。因为B未备案，所以无法直接访问80端口。所以我们在nginx的配置文件中将其端口改为2324 配置如下： 123456789server &#123; listen 2324 ; root /var/www/blog/; server_name _; location / &#123; try_files $uri $uri/ =404; &#125;&#125; 接着配置服务器A，大体的思路就是在服务器A上配置SSL证书，默认将80端口的访问rewrite到443端口，然后在443端口下进行相关配置。 配置如下： 1234567891011121314151617181920212223242526272829303132server &#123; listen 80; server_name blog.lihtao.com; rewrite ^(.*)$ https://$&#123;server_name&#125;$1 permanent; #&#125;# HTTPS server#server &#123; listen 443; #root /var/www/blog; #index index.html index.htm; ssl on; ssl_certificate cert/ssl.pem; ssl_certificate_key cert/ssl.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ## 反向代理 proxy_connect_timeout 180; proxy_send_timeout 180; proxy_read_timeout 180; proxy_set_header Host $host; proxy_set_header X-Forwarder-For $remote_addr; location / &#123; proxy_pass http://B服务器IP:2324; &#125;&#125; &#125; 如果还要进行图片防盗链、公益404等功能的配置，都可以直接在B服务器2324端口下配置。 如果有什么疑问可以留言]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2Flinux-0%2Fd0edc1ed.html</url>
    <content type="text"><![CDATA[发现很多使用过的Linux命令总是忘记，所以打算把常用的命名整理到这里 待更新 防火墙管理工具—iptablesiptables 中基本的命令参数 参数 作用 -P 设置默认策略 -F 清空规则链 -L 查看规则链 -A 在规则链的末尾加入新规则 -I num 在规则链的头部加入新规则 -D 删除某一条规则 -s 匹配来源地址 IP/MASK，加叹号“!”表示除这个 IP 外 -d 匹配目标地址 -i 匹配从这块网卡流入的数据 -o 匹配从这块网卡流出的数据 -p 匹配协议，如 TCP、 UDP、 ICMP –dport num 匹配目标端口号 -sport num 匹配来源端口号 常用命令在 iptables 命令后添加-L 参数查看已有的防火墙规则链：1iptables -L 在 iptables 命令后添加-F 参数清空已有的防火墙规则链：1iptables -F 把 INPUT 规则链的默认策略设置为拒绝：1iptables -P INPUT DROP 向 INPUT 链中添加允许 ICMP 流量进入的策略规则：1iptables -I INPUT -p icmp -j ACCEPT 删除 INPUT 规则链中刚刚加入的那条策略（允许 ICMP 流量），并把默认策略设置为允许：12iptables -D INPUT 1iptables -P INPUT ACCEPT 将 INPUT 规则链设置为只允许指定网段的主机访问本机的 22 端口，拒绝来自其他所有主机的流量：12iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPTiptables -A INPUT -p tcp --dport 22 -j REJECT 注意：防火墙策略规则是按照从上到下的顺序匹配的，因此一定要把允许动作放到拒绝动作前面，否则所有的流量就将被拒绝掉，从而导致任何主机都无法访问我们的服务。 向 INPUT 规则链中添加拒绝所有人访问本机 12345 端口的策略规则：12iptables -I INPUT -p tcp --dport 12345 -j REJECTiptables -I INPUT -p udp --dport 12345 -j REJECT 向 INPUT 规则链中添加拒绝 192.168.10.5 主机访问本机 80 端口（Web 服务）的策略规则：1iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT 向 INPUT 规则链中添加拒绝所有主机访问本机 1000～1024 端口的策略规则：12iptables -A INPUT -p tcp --dport 1000:1024 -j REJECTiptables -A INPUT -p udp --dport 1000:1024 -j REJECT 请特别注意，使用 iptables 命令配置的防火墙规则默认会在系统下一次重启时失效如果想让配置的防火墙策略永久生效，还要执行保存命令：1service iptables saveACCEPT（允许流量通过）、REJECT（拒绝流量通过）、LOG（记录日志信息）、DROP（拒绝流量通过），DROP是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“您的信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息 防火墙管理工具—firewalldfirewalld 中常用的区域名称及其规则 相较于传统的防火墙管理配置工具， firewalld 支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是 firewalld 预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。 区域 默认策略规则 trusted 允许所有的数据包 home 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关,则允许流量 internal 等同于home区域 work 区域拒绝流入的流量,除非与流出的流量数相关；而如果流量与ssh、ipp-client与 dhcpv6-client服务相关，则允许流量public | 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量external | 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量dmz | 拒绝流入的流量，除非与流出的流量相关；而如果流量与 ssh 服务相关，则允许流量block | 拒绝流入的流量，除非与流出的流量相关drop | 拒绝流入的流量，除非与流出的流量相关 终端管理工具firewalld-cmd 命令中使用的参数以及作用 参数 作用 –get-default-zone 查询默认的区域名称 –set-default-zone=&lt;区域名称&gt; 设置默认的区域，使其永久生效 –get-zones 显示可用的区域 –get-services 显示预先定义的服务 –get-active-zones 显示当前正在使用的区域与网卡名称 –add-source= 将源自此 IP 或子网的流量导向指定的区域 –remove-source= 不再将源自此 IP 或子网的流量导向某个指定区域 –add-interface=&lt;网卡名称&gt; 将源自该网卡的所有流量都导向某个指定区域 –change-interface=&lt;网卡名称&gt; 将某个网卡与区域进行关联 –list-all 显示当前区域的网卡配置参数、资源、端口以及服务等信息 –list-all-zones 显示所有区域的网卡配置参数、资源、端口以及服务等信息 –add-service=&lt;服务名&gt; 设置默认区域允许该服务的流量 –add-port=&lt;端口号/协议&gt; 设置默认区域允许该端口的流量 –remove-service=&lt;服务名&gt; 设置默认区域不再允许该服务的流量 –remove-port=&lt;端口号/协议&gt; 设置默认区域不再允许该端口的流量 –reload 让“永久生效”的配置规则立即生效，并覆盖当前的配置规则 –panic-on 开启应急状况模式 –panic-off 关闭应急状况模式 与 Linux 系统中其他的防火墙策略配置工具一样，使用 firewalld 配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd 命令正常设置防火墙策略时添加–permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行 firewall-cmd –reload 命令。 常用命令查看 firewalld 服务当前所使用的区域：1firewall-cmd --get-default-zone 查询 eno16777728 网卡在 firewalld 服务中的区域：1firewall-cmd --get-zone-of-interface=eno16777728 把 firewalld 服务中 eno16777728 网卡的默认区域修改为 external，并在系统重启后生效。分别查看当前与永久模式下的区域名称：123firewall-cmd --permanent --zone=external --change-interface=eno16777728firewall-cmd --get-zone-of-interface=eno16777728firewall-cmd --permanent --get-zone-of-interface=eno16777728 把 firewalld 服务的当前默认区域设置为 public：1firewall-cmd --set-default-zone=public 启动/关闭 firewalld 防火墙服务的应急状况模式，阻断一切网络连接（当远程控制服务器时请慎用）：12firewall-cmd --panic-onfirewall-cmd --panic-off 查询 public 区域是否允许请求 SSH 和 HTTPS 协议的流量：12firewall-cmd --zone=public --query-service=sshfirewall-cmd --zone=public --query-service=https 把 firewalld 服务中请求 HTTPS 协议的流量设置为永久允许，并立即生效：123firewall-cmd --zone=public --add-service=httpsfirewall-cmd --permanent --zone=public --add-service=httpsfirewall-cmd --reload 把 firewalld 服务中请求 HTTP 协议的流量设置为永久拒绝，并立即生效：12firewall-cmd --permanent --zone=public --remove-service=httpfirewall-cmd --reload 把在 firewalld 服务中访问 8080 和 8081 端口的流量策略设置为允许，但仅限当前生效：12firewall-cmd --zone=public --add-port=8080-8081/tcpfirewall-cmd --zone=public --list-ports 把原本访问本机 888 端口的流量转发到 22 端口，要且求当前和长期均有效： 流量转发命令格式为 firewall-cmd –permanent –zone=&lt;区域&gt; –add-forward-port=port=&lt;源端口号&gt;:proto=&lt;协议&gt;:toport=&lt;目标端口号&gt;:toaddr=&lt;目标 IP 地址&gt; 12firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10firewall-cmd --reload 然后客户端就可以使用ssh命令访问192.168.10.10 主机的 888 端口：12ssh -p 888 192.168.10.10 //或者ssh -p 888 root@192.168.10.10 创建会话网络 nmcli 是一款基于命令行的网络配置工具，功能丰富，参数众多。它可以轻松地查看网络信息或网络状态 查看网络状态：12nmcli connection shownmcli con show eno16777736 网络回话应用场景：如果我们在公司网络中使用笔记本电脑时需要手动指定网络的IP地址，而回到家中则是使用DHCP自动分配IP地址。这就需要麻烦地频繁修改IP地址，但是使用了网络会话功能后一切就简单多了—只需在不同的使用环境中激活相应的网络会话，可以实现网络配置信息的自动切换了。 使用con-name参数指定公司所使用的网络会话名称company，然后依次用ifname参数指定本机的网卡名称，用`autoconnect no 参数设置该网络会话默认不被自动激活，以及用 ip4 及 gw4 参数:1nmcli connection add con-name company ifname ens33 autoconnect no type ethernet ipv4.addresses 192.168.45.10/24 ipv4.gateway 192.168.45.1 使用 con-name 参数指定家庭所使用的网络会话名称 house。因为我们想从外部DHCP服务器自动获得IP地址，因此这里不需要进行手动指定：1nmcli connection add con-name house ifname ens33 可以使用 nmcli 命令查看创建的所有网络会话：1nmcli connection show 使用nmcli命令配置过的网络会话是永久生效的，下班回家后启用house网络会话，网卡就能自动通过DHCP获取到IP地址了。1nmcli connection up house 删除网络会话1nmcli connection delete house 如果使用的是虚拟机，请把虚拟机系统的网卡（网络适配器）切换成桥接模式 待整理1、Linux下关闭终端继续运行进程 后台运行：1./test.sh &amp; 就是在相应命令的后面添加 ` &amp;`，其他可执行文件一样 关闭终端之后继续运行：1nohup ./test.sh &amp; 显示当前正在执行的进程： top命令 2、端口及进程管理 查看端口占用情况：1lsof -i :端口号 强制中止端口进程：1234kill -9 $(lsof -i tcp:端口号 -t)非root用户：kill -9 $(sudo lsof -i tcp:端口号 -t) 这篇文章中的很多内容来自刘遄老师的《Linux就该这么学》，一来防止忘记，二来方便以后查看。]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程连接MySQL]]></title>
    <url>%2F2018%2Fmysql-0%2F88d723d5.html</url>
    <content type="text"><![CDATA[记录一下远程连接Linux下的mysql操作流程。 首先登陆Linux下的mysql 1mysql -uroot -p(密码) 创建用户 1GRANT ALL PRIVILEGES ON *.* TO &apos;用户名&apos;@&apos;%&apos; IDENTIFIED BY &apos;密码&apos; WITH GRANT OPTION; ‘%’代表在任何一台电脑都可以登陆 使更改立即生效 1flush privileges; 查看数据库用户 1SELECT DISTINCT CONCAT(&apos;User: &apos;&apos;&apos;,user,&apos;&apos;&apos;@&apos;&apos;&apos;,host,&apos;&apos;&apos;;&apos;) AS query FROM mysql.user; 用exit退出mysql 修改mysql 1vim /etc/mysql/mysql.conf.d/mysqld.cnf 将bind-address 127.0.0.1改为bind-address 0.0.0.0 重启mysql 1/etc/init.d/mysql restart 查看端口 1show global variables like &apos;port&apos;; 然后使用navicat连接]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装kali虚拟机]]></title>
    <url>%2F2018%2Fkali-vm%2F8d2aafa7.html</url>
    <content type="text"><![CDATA[这篇文章整理一下安装Kali虚拟机的过程，以及一些简单的配置问题。 安装 官网下载Vm虚拟机的压缩包 解压，然后直接在VMware中打开 配置网络 无法连接网络 更改/etc/network/interfaces文件中的内容 如果虚拟机无法连接网络，在interfaces中添加： 12auto eth0iface eth0 inet dhcp 修改并保存，然后/etc/init.d/networking restart重启网络。 配置静态IP 更改/etc/network/interfaces文件： 12345auto eth0iface eth0 inet static //配置eth0使用默认的静态地址address 192.163.2.123 //设置eth0的IP地址netmask 255.255.255.0 //设置eth0的子网掩码gateway 192.163.2.11 //设置当前主机的默认网关 重启网络同上。 使用主机代理 将主机VPN代理设置为允许来自局域网的连接一般端口都为1080，也可以自己设置，只要端口不被占用就可以。 然后设置虚拟机网络代理为手动，设置设置如下： 之后就可以使用google了： 安装常用软件 安装中文输入法 更新源 1apt-get update 安装fcitx 1apt-get install fcitx 安装google拼音输入法 1apt-get install fcitx-googlepinyin 重启系统 1reboot 之后就可以使用ctrl+空格切换中英文输入 安装chrome 浏览器中下载chrome的.deb安装包，如下： 然后使用gdebi进行安装 首先安装gdebi 1apt-get install gdebi -y 然后使用gdebi安装chrome 1gdebi google-chrome-stable_current_amd64.deb 安装后发现chrome无法打开 打开终端，输入 12cd /usr/binvim google-chrome 在最后输入--no-sandbox，保存。 然后就可以启动chrome了。 快捷键 终端快捷键]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将Hexo部署到vps，实现自动发布]]></title>
    <url>%2F2018%2Fvps%2F22a52aa9.html</url>
    <content type="text"><![CDATA[​ 博客一直放在GitHub上面，今天放到了服务器上，记录了一下简单的流程。供大家参考！ hexo相关文章： 用Hexo搭建博客 Maupassant主题个性化 搭建流程 服务器环境配置，安装Git、Nginx配置、创建git用户 本地hexo初始化 使用Git自动部署并发布博客 服务器环境搭建 安装Git和NodeJS(Centos环境) 123yum install git# 安装NodeJS curl --silent --location https://rpm.nodesource.com/setup_5.x | bash - 创建git账号 123adduser gitchmod 740 /etc/sudoersvim /etc/sudoers 添加内容找到 12## Allow root to run any commands anywhereroot ALL=(ALL) ALL 添加以下内容 1git ALL=(ALL) ALL 保存退出并改回权限 1chmod 400 /etc/sudoers 设置git账号密码 1sudo passwd git 使用su git切换到git用户，再执行下列操作： 1234567891011# 切换到git用户目录cd /home/git# 创建.ssh文件夹mkdir ~/.ssh# 创建authorized_keys文件并编辑vim ~/.ssh/authorized_keys# 如果你还没有生成公钥，那么首先在本地电脑中执行 cat ~/.ssh/id_rsa.pub | pbcopy生成公钥# 再将公钥复制粘贴到authorized_keys# 保存关闭authorized_keys后，修改相应权限chmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh 然后可以通过本地Git Bash执行ssh命令测试是否可以免密登录 1ssh -v git@服务器ip地址 这样git用户就添加好了。 安装Nginx 准备工作首先由于nginx的一些模块依赖一些lib库，所以在安装nginx之前，必须先安装这些lib库，这些依赖库主要有g++、gcc、openssl-devel、pcre-devel和zlib-devel 所以执行如下命令安装 1234yum install gcc-c++ yum install pcre pcre-devel yum install zlib zlib-devel yum install openssl openssl--devel 安装Nginx安装之前，最好检查一下是否已经安装有nginx 1find -name nginx 如果系统已经安装了nginx，那么就先卸载 1yum remove nginx 然后开始安装首先进入/usr/local目录1cd /usr/local 从官网下载最新版的nginx1wget -c https://nginx.org/download/nginx-1.12.1.tar.gz （注：版本号可更改，去官网查看最新版本号修改即可） 解压nginx压缩包1tar -zxvf nginx-1.12.1.tar.gz 会产生一个nginx-1.12.1 目录，这时进入nginx-1.12.1 目录1cd nginx-1.12.1 接下来安装，使用–prefix参数指定nginx安装的目录,make、make install安装1./configure （默认安装在/usr/local/nginx，推荐使用默认设置） 1make 1make install 如果没有报错，顺利完成后，最好看一下nginx的安装目录 1whereis nginx （where和is要连这些，中间没有空格） 启动和停止nginx 1234567cd /usr/local/nginx/sbin/./nginx ./nginx -s stop./nginx -s quit./nginx -s reload./nginx -s quit: 此方式停止步骤是待nginx进程处理任务完毕进行停止。./nginx -s stop: 此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。 查询nginx进程：1ps aux | grep nginx 重启 nginx 先停止再启动（推荐）：对 nginx 进行重启相当于先停止再启动，即先执行停止命令再执行启动命令。如下： 12./nginx -s quit./nginx 重新加载配置文件：当 nginx 的配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，使用 -s reload 不用先停止 nginx 再启动 nginx 即可将配置信息在 nginx 中生效，如下： 1./nginx -s reload 启动成功后，在浏览器可以看到如下页面： 开机自启动 即在rc.local增加启动代码就可以了。 1vim /etc/rc.local 增加一行 1/usr/local/nginx/sbin/nginx 到这里，nginx安装完毕，启动、停止、重启操作也都完成。 建立git裸库1234# 回到git目录cd /home/git# 使用git用户创建git裸仓库，以blog.git为例git init --bare blog.git 检查用户组权限我们的git裸仓库已经建立好了，离成功又近了一步。为了以防万一，我们要检查一下之前的blog.git、.ssh、blog目录的用户组权限是否都为git:git​ 1234​ # 还记得/var/www/吗？这是之前配置nginx时，我们自己选定的网站根目录，请依据你自己的设置更改​ ll -a /var/www/​ ll -a /home/git/​ 如果有哪个不是，执行下面相应的命令后再查看12sudo chown git:git -R /var/www/blogsudo chown git:git -R /home/git/blog.git 使用git-hooks同步网站根目录简单来说，我们使用一个钩子文件：post-receive，每当git仓库接收到内容的时候，就会自动调用这个钩子，把内容同步到网站根目录。​ 在git用户下执行： 12# 新建一个post-receive文件并编辑vim ~/blog.git/hooks/post-receive 在里面输入以下内容，注意修改为自己的设置： 12345678#!/bin/bashGIT_REPO=/home/git/blog.gitTMP_GIT_CLONE=/tmp/blogPUBLIC_WWW=/var/www/blogrm -rf $&#123;TMP_GIT_CLONE&#125;git clone $GIT_REPO $TMP_GIT_CLONErm -rf $&#123;PUBLIC_WWW&#125;/*cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125; 保存退出后，执行：chmod +x post-receive赋予这个文件可执行权限。 好了，以上就是服务器端需要配置的内容。我们还差最后一步就可以完成整个部署了！ 修改配置文件nginx_config修改上面的配置文件：1vim /usr/local/nginx/conf/nginx_config 然后修改其中两个部分，如下所示： 然后重启nginx，方法见nginx安装部分。 配置本地Hexo的_config.yml非常简单，只需要找到本地Hexo博客的站点配置文件_config.yml，找到以下内容并修改： 1234deploy: type: git repo: git@你的服务器IP:/home/git/blog.git branch: master 保存后，剩下的就是Hexo的日常操作了，这里就不赘述了，写完文章后，在你的本地博客根目录执行以下命令： 1hexo c &amp;&amp; hexo g -d 就可以实现线上博客的自动更新了！一切搞定！ 一些需要注意的地方 vim: command not found解决方法：安装vim 1yum -y install vim* 设置防火墙 开启80端口，并重新启动防火墙]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maupassant主题个性化]]></title>
    <url>%2F2018%2Fmaupassant%2Fb3f8163.html</url>
    <content type="text"><![CDATA[其实官方文档说的已经很清楚了，当然还是有一些小坑，我就填一下吧。 hexo相关文章： 用Hexo搭建博客 将Hexo部署到vps，实现自动发布 主要内容 Disqus评论系统 不蒜子页面访问计数 添加捐赠按钮 网站图标 添加页面 中文设置 等等 详细操作步骤 Disqus评论系统 Hexo添加评论系统，这篇文章写的很详细，步骤都很简单 不蒜子页面访问计数 修改_config.yml文件中的busuanzi为true 因为作者没有使用的原因，并未发现不蒜子的域名已经改变，所以如果想要添加计数功能，需修改主题中的部分代码 12345if theme.busuanzi == true script(src=&apos;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&apos;, async) span#busuanzi_container_page_pv= &apos; | &apos; span#busuanzi_value_page_pv span= &apos; &apos; + __(&apos;Hits&apos;) 将上面代码中的dn-lbstatics.qbox.me修改为busuanzi.ibruce.info即可。 注： 添加捐赠按钮 首先修改主题中间中donate相关的配置，再将相应的图片放到\themes\maupassant\source\img\文件夹下 网站图片 若要设置网站Favicon，可以将favicon.ico放在Hexo根目录的source文件夹下，建议的大小：32px*32px。 注：因为浏览器缓存的原因，可以换个浏览器，或者等待一段时间重新加载 添加页面 在根目录的source文件夹下添加相应的文件夹，例如：about、guestbook、history等。并在相应的文件中添加index.md文件。 根目录下的source目录结构如下： ![目录结构](https://lihtao-1257343120.cos.ap-shanghai.myqcloud.com/blog/hexo2.png) 设置中文 将根目录下的_config.yml中的language设置如下： 1language: zh-CN 即可]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Hexo搭建博客]]></title>
    <url>%2F2018%2Fhexo%2F63c39d22.html</url>
    <content type="text"><![CDATA[最近用hexo搭建了自己的博客，之前是挂在GitHub上，今天又将博客放在了自己的服务器上，中间遇到了不少坑，分享一下搭建博客的过程。 用到的工具 Git Nodejs Hexo Github Pages SSH配置 域名解析 大概就这些吧。 本地建站 安装Hexo 根据官方文档，安装Hexo的前提是先安装Node.js和Git(安装过程很简单，网上有很多教程，此处不详细展开) 安装Hexo只需要在终端(cmd、Git bash、Node.js、command prompt均可)中敲入如下命令： 1npm install -g hexo-cli 建立站点 在电脑中建立准备搭建博客的文件夹，比如文件夹D:\Blog； 在终端切换到Blog文件夹 如果默认的npm镜像太慢，可以切换到淘宝镜像或者使用代理 1npm config set registry &quot;https://registry.npm.taobao.org&quot; 依此执行下面两条命令，初始化hexo，安装npm 12hexo initnpm install 执行完这两条命令后，Blog下的目录结构如下： 目录结构说明： _config.yml 文件存放着网站的配置信息，可以在这里配置大部分的参数。 package.json 文件存放着插件信息，从中可以查看那些插件已经安装。 scaffolds 是模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件，不过这个模板和后面的主题里指的模板不一样。 source 是存放用户资源的地方的文件夹，除 _posts 文件夹之外，开头命名为 _ (下划线) 的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹（别急，等下会生成的），而其他文件会被拷贝过去。 themes 主题文件夹，Hexo 会根据主题来生成静态页面，我们以后自己安装的主题也都会放在这个文件夹下面，默认的 landscape 主题已经在里面了。 在终端输入hexo server，可以在 http://localhost:4000/ 中查看网站的样子。 修改配置文件 在_config.yml文件中，我们暂时可以修改其中的title，subtitle和author,替换成自己网站的名字和作者名字即可。 添加文章 在 _posts 文件夹下，新建一个 Markdown 文件，或者把你以前有的 Markdown 文件复制进来，根据 Hexo 的官方文档 基本操作 — Front-matter ，写好你的第一篇文章。 其中首部的两条---分割线内的内容即为Front-matter 在终端输入 1hexo generate Hexo 会替我们刚加入到 _posts 文件夹下的 markdown 文件生成静态文件。运行 hexo server 可以在 http://localhost:4000/ 中看到我们新添加的网页内容了。至此，我们采用默认主题 landscape 的网站已经生成了，且相信你已经掌握了关于 Hexo 的大部分操作，如果自感还不熟悉，可以再看看 Hexo 的官方文档 开始使用 — 命令， 主要是下面几个命令： hexo init [folder]: 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站； hexo generate: 生成静态文件； hexo server: 启动服务器。默认情况下，访问网址为： http://localhost:4000/； hexo deploy: 部署网站（后文会用得）； hexo clean: 清除缓存文件 (db.json) 和 public 文件夹下已生成的静态文件。 更换主题 我们可以去 Themes | Hexo 中挑选喜欢的主题。 比如主题maupassant，我们可以打开其GitHub主页，然后安装 123$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save 依此执行上面三条命令，完成安装 然后将Blog/_config.yml中的theme的值又默认的landscape改为maupassant。 再次在终端输入 123hexo cleanhexo generatehexo server 现在我们就可以在本地4000端口查看网站的样式 部署到GitHub 创建GitHub仓库 要在 Github 上创建项目，当然首先需要注册 Github帐号。在注册完成后，Github 的官方文档 Create a new repository on GitHub 已经图文并茂将如何建立一个 repository 交待得非常清楚明白了，唯一要注意的是，第二步里的 Repository name 一定要是 your_name.github.io ，your_name 是你的 Github 用户名。 配置Git 根据 Github 的官方文档 Setting up Git，这一操作的目的是 Tell Git your name so your commits will be properly labeled 和 Tell Git the email address that will be associated with your Git commits，也就是告诉版本控制软件 Git 接下来这台电脑上提交的文件是 E-mail 地址是什么的谁谁谁提交的。在 Git Bash 中执行如下代码即可： 12git config --global user.name &quot;YOUR NAME&quot;git config --global user.email &quot;YOUR EMAIL ADDRESS&quot; 其中，YOUR NAME 是自己取的名字，YOUR EMAIL ADDRESS 是自己的邮箱。由于自己的博客网站就自己一个人提交，所以就都设置成跟 Github 用户名和邮箱相同了。但其实是可以不同的，因为对于很多项目，并不只有一个开发者，Github 允许多人向同一个 Repo 提交，这里提供用户名和邮箱，只是为了搞清楚哪些代码是谁谁谁提交的。 生成SSH key 根据 Github 的官方文档 Generating a new SSH key ， 我们在 Git Bash 下执行如下命令，生成 SSH key 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 其中，`your_email@example.com` 是你的 Github 注册邮箱。然后，Git Bash 中会出现 1Generating public/private rsa key pair. 表示新的 SSH 已经生成了。随后会出现 12Enter a file in which to save the key(/Users/you/.ssh/id_rsa): [Press enter] 这里 id_rsa 是生成的 key 文件的文件名，默认都是这个；如果不是，在后面用到 id_rsa 的地方请替换成出现的名字。这条信息是让你选择 SSH key 存放的地点，按回车选择默认的即可。回车后，还会出现 12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 让你设置使用 SSH 密钥时的密码，由于我们都是在自己个人的电脑上操作，所以仍然回车，不设置密码即可。 将SSH key添加到ssh-agent 根据 Wikipedia，ssh-agent 是一个在本地登录会话持续时间内，将未加密的密钥存储在内存中，并使用 Unix 域套接字与 SSH 客户端进行通信的程序。根据 Github 的官方文档 Adding your SSH key to the ssh-agent ， 我们在 Git Bash 下执行如下命令，开启 ssh-agent 1eval &quot;$(ssh-agent -s)&quot; 然后我们要将这个 SSH key 添加到 ssh-agent 里去，运行如下命令，其中 id_rsa 是你的 key 文件的文件名： 1ssh-add ~/.ssh/id_rsa 将SSH key 添加到 GitHub 账户 Github 的官方文档 Adding a new SSH key to your GitHub account 已经图文并茂将如何在 Github 帐号中添加 SSH 介绍的非常清楚了。先是在 Git Bash 中将 SSH Key 拷贝出来： 12$ clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard id_rsa 是你刚才的 SSH Key 文件。此时，SSH Key 已经在我们的剪切板里了。然后登录 Github 帐号，依次点击自己的头像，Settings，SSH and GPG keys，New SSH key 或者 Add SSH key， 在 Title 这里输入 Key 的label，比如 your_name - PC，然后在 Key 里面把 SSH Key 粘贴进去，点击 Add SSH key 大功告成。 回想一下，操作了那么多 SSH 相关的命令，我们在干嘛？个人的理解，就是在生成身份认证的凭证 SSH key，分别放在自己本地电脑和 Github 服务器上，以后向 Github 提交内容的时候，两者的 Key 匹配就可以了，省去了我们每次输密码的时间。 测试SSH连接 在大功告成之前，为了稳妥起见，我们来测试一下自己跟 Github 服务器 SSH 连接是否已经建立起来了。Github 的官方文档 Testing your SSH connection 已经将次环节介绍得非常详细了。我们要做得就是在 Git Bash 中敲入 1ssh -T git@github.com 你可能会看到类似于 123The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 没关系的，输入 yes 敲回车，就可以看到如下的成功信息了 12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 至此为止，我们已经建立起了跟 Github 服务器的连接。其实我们也可以用 git push 命令，提交 public 文件夹下面的内容，不过 Hexo 更我们提供了更方便的途径。 Hexo 部署 Hexo 提供了 hexo deploy 命令，可以方便地将整个 public 文件夹部署到 Github 服务器上去。根据 Hexo 的官方文档 基本操作 — 部署 我们只需要做以下两步： 安装hexo-deployer-git插件： 1npm install hexo-deployer-git --save 修改_config.yml中的参数： 1234deploy: type: git repo: https://github.com/your_name/your_name.github.io.git branch: master 其中，your_name 是你的 Github 帐号名。repo 对应的是你 your_name.github.io 这个项目的库（Repository）地址，进入这个项目的主页，点击 Clone or download 下拉菜单也能看到。branch 是分支名称，如果使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测，通常都是 master。 注意，冒号后的空格非常重要，一定要有！ 绑定独立域名看到这里，恭喜你已经拥有了域名为 your_name.github.io 的个人博客网站了，进一步的，就是希望能够在浏览器中输入自己的域名，比如 your.site，就可以看到自己的网站。停下来思考一下，要实现这一目的，我们需要干什么？首先，当然我们要去买一个域名。买完域名后呢？怎么要让浏览器知道这个域名对应的网站内容在 Github 服务器上？这就是域名解析的事情啦。这是浏览器这里，还有 Github 服务器呢？Github 服务器上存放着那么多个人网站，怎么在收到浏览器一个要访问我的域名为 your.site这个站点内容的时候，准确的把我的站点的内容送出来呢？这就是要在自己提交的 public 文件夹下添加 CNAME 文件了。一共 3 个环节，我们一个一个来介绍。 购买域名 我的域名是在阿里云的万网上买的 域名解析 阿里云提供域名的免费解析，当然你也可以其他的域名解析服务 告诉 GitHub your_name.github.io 对应那个域名 在 source 文件夹下添加一个 CNAME 文件，里面就一行内容，写上自己的域名，比如 your.site。 在终端中运行 1hexo generate Hexo 在生成 public 文件夹内容的时候，会自动把 CNAME 文件复制过去，这样，public 文件夹下就也有 CNAME 文件了。再运行 1hexo deploy 将其部署到 Github，让 Github 知道 your_name.github.io 对应哪个域名。]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2Fhello-world%2F4a17b156.html</url>
    <content type="text"><![CDATA[Hello Word！]]></content>
      <categories>
        <category>emotion</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
